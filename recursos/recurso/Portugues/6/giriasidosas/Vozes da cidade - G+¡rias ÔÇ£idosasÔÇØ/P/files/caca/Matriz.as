package caca {	import flash.display.MovieClip;	import flash.events.MouseEvent;	import flash.events.KeyboardEvent;	import flash.ui.Keyboard;			import caca.Letra;	import caca.Selecao;	import caca.Dica;	import caca.eventos.EventoMatriz;		public class Matriz extends MovieClip {		var matriz:Array;		var largura:int; 		var altura:int;		var selecao:Selecao;		var selecoes:Array;		var gabarito:Array;		var banco:Array;		var selecionando:Boolean;		var foco:MovieClip;				public function Matriz() {			largura = 18;			altura = 18;			selecao = null;			selecoes = new Array();			gabarito = new Array();			selecionando = false;			gerarGrade();			addEventListener(KeyboardEvent.KEY_DOWN, _gerenciarTeclado);		}				public function limpar():void {			var sel:Selecao;			/* remove as seleções que ainda são filhas da matriz (palavras válidas)*/			while(selecoes.length > 0) {				sel = selecoes.pop();				if(sel.parent != null)					removeChild(sel);			}			preencherGrade();		}				public function setBanco(banco:Array):void {			this.banco = banco;			embeberBanco();		}		/*		 * Gera a grade de letras interna da matriz		 */		function gerarGrade()		{			matriz = new Array();			var ti:int = 0;			for (var j = 0; j < altura; j++)				{				matriz[j] = new Array();				for (var k = 0; k < largura; k++)				{					var l:Letra = new Letra();					matriz[j][k] = l;					l._x_ = j;					l._y_ = k;					l.x = 10 + j*l.width;					l.y = 10 + k*l.height;					l.addEventListener(MouseEvent.MOUSE_DOWN, _iniciarPalavra);					l.addEventListener(MouseEvent.MOUSE_OVER, _circularPalavra);					l.addEventListener(MouseEvent.MOUSE_UP, _notificarSelecao);					l.addEventListener(MouseEvent.MOUSE_OUT, _normalizarLetra);					//l.tabIndex = ti++;					l.tabChildren = false;					addChild(l);														}			}		}				function preencherGrade() {			for (var j = 0; j < largura; j++)				{				for (var k = 0; k < altura; k++)				{					var l:String = String.fromCharCode (Util.randi (65, 91));					matriz[j][k].resetar(l);				}			}					}						function _iniciarPalavra(e:MouseEvent):void {			iniciarPalavra(e.currentTarget as Letra);			stage.addEventListener(MouseEvent.MOUSE_UP, mouseupGlobal);		}			function _circularPalavra(e:MouseEvent):void {			if(e.buttonDown) {				circularPalavra(e.currentTarget as Letra);			}		}				function _notificarSelecao(e:MouseEvent):void {			notificarSelecao();		}									function _normalizarLetra(e:MouseEvent):void {			(e.currentTarget as Letra).letraNeutra();		}				function mouseupGlobal(e:MouseEvent):void {			if(!(e.currentTarget is Letra))				notificarSelecao();		}				function iniciarPalavra(letra:Letra) {			/* ao escolher uma letra, faz com que ela seja o início da seleção */			selecionando = true;			selecao = new Selecao(letra);			selecao.setFim(selecao.getInicio());			selecao.desenhar();			addChild(selecao);		}				function circularPalavra(letra:Letra) {			if(selecao.letraFinalValida(letra)) {				selecao.setFim(letra);				selecao.desenhar();								letra.letraValida();			}			else {				letra.letraInvalida();			}		}				function notificarSelecao():void {			var sel:Selecao = selecao;			stage.removeEventListener(MouseEvent.MOUSE_UP, mouseupGlobal);			selecionando = false;			selecoes.push(sel);			var evt:EventoMatriz = new EventoMatriz(EventoMatriz.SELECAO_PALAVRA, {selecao: this.selecao, palavra: obterPalavra()});			dispatchEvent(evt);		}						/* 		 * obtém a palavra atualmente selecionada 		*/		function obterPalavra():String {			var tamanhoX:int = selecao.getFim()._x_ - selecao.getInicio()._x_;			var tamanhoY:int = selecao.getFim()._y_ - selecao.getInicio()._y_;			var tamanho:int = 0;						var incrementoX:int = 0;			var incrementoY:int = 0;									if(tamanhoX == 0) {				/* a palavra está na vertical */				tamanho = Math.abs(tamanhoY);				incrementoX = 0;				incrementoY = tamanhoY / tamanho;			}			else if(tamanhoY == 0) {				/* a palavra está na horizontal */				tamanho = Math.abs(tamanhoX);				incrementoY = 0;				incrementoX = tamanhoX / tamanho;			}			else {				/* a palavra está na diagonal */				tamanho = Math.abs(tamanhoX);				incrementoX = tamanhoX / tamanho;				incrementoY = tamanhoY / tamanho;			}							var palavra:String = "";			tamanho += 1;			for ( var i=0; i<tamanho; i++ ) {				palavra += matriz[selecao.getInicio()._x_ + i*incrementoX][selecao.getInicio()._y_ + i*incrementoY].letra;			};						return palavra;		}				function inserirPalavra(word:String, index_j:int, index_k:int, possible_directions):Boolean {			// shuffle the directions to get one randomly			Util.shuffle(possible_directions);			if (this.gabarito.length < (.2 * this.banco.length)) {				possible_directions.sortOn("length");			}			// try all of the directions to find one that works			for (var j = 0; j < possible_directions.length; j++) {				// calculate the slope of the word based on the direction				var increments=this.calculate_slope_increments(possible_directions[j]);				// check if a word is in the path of this word at this slope				if (! this.word_overlaps(word,index_j,index_k,increments)) {					// put the word's letters into the grid					this.inserirLetras(word, index_j, index_k, increments, possible_directions[j]);					return (true);				}			}			return (false);				}				// check if a word is in the path of this word at this slope		function word_overlaps(word:String, index_j:int, index_k:int, increments) {			// loop through the current grid to try to find some overlapping			for (var n = 0; n < word.length; n++) {				// calculate the indicies of the letter				var j=index_j+n*increments.j;				var k=index_k+n*increments.k;				// get a reference to the letter in the grid				var letter:Letra = this.matriz[j][k];				// check if the letter has already been set				if (letter.estahNoBanco && (letter.letra != word.charAt(n))) {					return (true);				}			}			// if the code got this far then there was no overlapping			return (false);		}								// calculates the slope of the word based on the direction		function calculate_slope_increments(direction:String):Object {			// return the slope information			if (direction=="Top Left to Bottom Right") {				return ( { j:1,  k:1  } );			} else if (direction == "Bottom Left to Top Right") {				return ( { j:-1, k:1  } );			} else if (direction == "Top Right to Bottom Left") {				return ( { j:1,  k:-1 } );			} else if (direction == "Bottom Right to Top Left") {				return ( { j:-1, k:-1 } );			} else if (direction == "Left to Right") {				return ( { j:0,  k:1  } );			} else if (direction == "Right to Left") {				return ( { j:0,  k:-1 } );			} else if (direction == "Top to Bottom") {				return ( { j:1,  k:0  } );			} else if (direction == "Bottom to Top") {				return ( { j:-1, k:0  } );			}			return(null);		}								// puts the word's letters into the grid		function inserirLetras(word:String, index_j:int, index_k:int, increments, direction) {			// loop through the current grid to try to find some overlapping			for (var n = 0; n < word.length; n++) {				// calculate the indicies of the letter				var j=index_j+n*increments.j;				var k=index_k+n*increments.k;				// get a reference to the letter in the grid				var letter=this.matriz[j][k];				// set the properties of the letter				letter.estahNoBanco = true;				letter.resetar(word.charAt(n));			}			/* guarda os parâmetros de localização da palavra (se for preciso exibir as respostas, por exemplo)*/			var resposta = new Object ( );			resposta.start={j:index_j,k:index_k};			resposta.length=word.length;			resposta.increments=increments;			resposta.direction=direction;			resposta.palavra=word;			this.gabarito.push(resposta);		}												function obterDirecoesPossiveis(word_length:int, index_j:int, index_k:int) {			// list of possible directions for the word			var directions = new Array ( );			// check if the word is contained within the grid			// down, right			if (((index_j + word_length) < this.altura) &&			((index_k + word_length) < this.largura)) {				directions.push("Top Left to Bottom Right");			}			// down, left			if (((index_j + word_length) < this.altura) &&			((index_k - word_length) >= 0)) {				directions.push("Top Right to Bottom Left");			}			// up, right			if (((index_j - word_length) >= 0) &&			((index_k + word_length) < this.largura)) {				directions.push("Bottom Left to Top Right");			}			// up, left			if (((index_j - word_length) >= 0) &&			((index_k - word_length) >= 0)) {				directions.push("Bottom Right to Top Left");			}			if ((index_j + word_length) < this.altura) {				directions.push("Top to Bottom");			}			if ((index_j - word_length) >= 0) {				directions.push("Bottom to Top");			}			if ((index_k + word_length) < this.largura) {				directions.push("Left to Right");			}			if ((index_k - word_length) >= 0) {				directions.push("Right to Left");			}			// return the list of possible directions			return (directions);		}								/* 			Insere as palavras do banco de palavras na matriz de letras				*/		function embeberBanco():void {			// get a copy of the word bank so we can add on to it without affecting the actual bank			var temp_bank = Util.clonarArray(banco); 			// loop through the words in the word bank, which will be embedded in the grid			for (var j = 0; j < temp_bank.length; j++) {				// calculate a random position for the word to start in the grid				var index_j = Util.randi(0, this.altura);				var index_k = Util.randi(0, this.largura);				// get a list of possible directions the word could branch off from here				var possible_directions=this.obterDirecoesPossiveis(temp_bank[j][4].length,index_j,index_k);				// embed the word into the grid				var bool=this.inserirPalavra(temp_bank[j][4],index_j,index_k,possible_directions);				// if the word was not properly embedded try again				if (! bool) {					temp_bank.push(temp_bank[j]);				}			}					}				function _gerenciarTeclado(e:KeyboardEvent):void {			if(foco==null) 				foco = matriz[altura/2][largura/2];			Dica.ocultar();			switch (e.keyCode) {				case Keyboard.ENTER:					desfocar();					if(!selecionando)						iniciarPalavra(foco as Letra);					else						notificarSelecao();				break;				case Keyboard.ESCAPE:					desfocar();					if(selecionando) 						notificarSelecao();				break;				case Keyboard.LEFT:					if(selecionando) {						foco.letraNeutra();						if(foco._x_ > 0) {							circularPalavra(matriz[foco._x_ - 1][foco._y_]);							foco = matriz[foco._x_ - 1][foco._y_]						}					}					else {						/* vai para a letra acima, se houver */						if(foco._x_ > 0) 							focar(matriz[foco._x_-1][foco._y_]);						else							focar(matriz[largura-1][foco._y_]);									}									break;				case Keyboard.RIGHT:					if(selecionando) {						foco.letraNeutra();						if(foco._x_ < largura-1) {							circularPalavra(matriz[foco._x_ + 1][foco._y_]);							foco = matriz[foco._x_ + 1][foco._y_]												}					}					else {						/* vai para a letra acima, se houver */						if(foco._x_ < largura-1) 							focar(matriz[foco._x_+1][foco._y_]);						else							focar(matriz[0][foco._y_]);									}				break;				case Keyboard.UP:					if(selecionando) {						foco.letraNeutra();						if(foco._y_ > 0) {							circularPalavra(matriz[foco._x_][foco._y_-1]);							foco = matriz[foco._x_][foco._y_-1];								}									}					else {						/* vai para a letra acima, se houver */						if(foco._y_ > 0) 							focar(matriz[foco._x_][foco._y_-1]);						else							focar(matriz[foco._x_][altura-1]);									}								break;				case Keyboard.DOWN:					if(selecionando) {						foco.letraNeutra();						if(foco._y_ < altura-1) {							circularPalavra(matriz[foco._x_][foco._y_+1]);							foco = matriz[foco._x_][foco._y_+1];												}					}					else {						/* vai para a letra abaixo, se houver */						if(foco._y_ < altura-1) 							focar(matriz[foco._x_][foco._y_+1]);						else							focar(matriz[foco._x_][0]);									}								break;			}		}							function focar(mc:MovieClip):void {			desfocar();			mc.gotoAndStop("selecionada");			foco = mc;		}		public function desfocar():void {			if(foco != null) {				foco.gotoAndStop("normal");			}		}															}}